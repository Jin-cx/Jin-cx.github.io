{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"webpack","slug":"webpack","date":"2021-05-15T13:22:14.000Z","updated":"2021-05-25T07:06:14.489Z","comments":true,"path":"2021/05/15/webpack/","link":"","permalink":"http://example.com/2021/05/15/webpack/","excerpt":"Webpack","text":"Webpack Webpack的五个核心概念 Entry 入口 Output 输出 Loader Loader让Webpack能够去处理非JS文件（Webpack自身只理解JS） Plugins 插件（Plugins）可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量 Mode 选项 描述 特点 develpment 会将process.env.NODE_ENV的值设为development。启用NameChunksPlugin和NamedModulesPlugin。 能让代码本地调试运行的环境 production 会将process.env.NODE_ENV的值设为production。启用FlagDependencyUsagePlugin，FlagIncludedChunksPlugin，ModuleConcatenationPlugin，NoEmitOnErrorsPlugins，OccurenceOrderPlugin，SideEffectsFlagPlugin和UglifyJsPlugin 能让代码优化上线运行的方式 Webpack初体验","categories":[],"tags":[]},{"title":"ES6","slug":"ES6","date":"2021-05-06T12:15:46.000Z","updated":"2021-05-13T12:42:01.087Z","comments":true,"path":"2021/05/06/ES6/","link":"","permalink":"http://example.com/2021/05/06/ES6/","excerpt":"ES6–let和const命令ECMAScript6(ES6)是JavaScript的国际标准，两者之间的关系为ECMAScript和JavaScript的规格，JavaScript是ECMAScript的一种实现。","text":"ES6–let和const命令ECMAScript6(ES6)是JavaScript的国际标准，两者之间的关系为ECMAScript和JavaScript的规格，JavaScript是ECMAScript的一种实现。 2.1 let命令1、ES6新增了let命令用于声明变量，类似于var,但是所声明的变量只在let命令所在的代码块内有效。 2、var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则会报错。 12345var tmp=123;if(true)&#123; tmp=&#x27;abc&#x27;;//ReferenceError let tmp;&#125; 3、ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前就使用这些变量，就会报错。在语法上称为“暂时性死区。” 12var x=x//不报错let x=x//报错 x is not defined 4、ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致错误。 5、不允许在相同作用域内重复声明同一个变量，因此不能在函数内部重新声明参数。 123456789function(arg)&#123; let arg;//报错&#125;function(arg)&#123; &#123; let arg;//不报错 &#125;&#125; 2.2 块级作用域1234567891011//IIFE写法(function()&#123; var tmp=...; ...&#125;()); //块级作用域写法 &#123; let tmp=...; ... &#125; 6、块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数(IIFE)不再必要了。 7、ES6（1）允许在块级作用域内声明函数；（2）函数声明类似于var,即会提升在全局作用域或函数作用域的头部。（3）函数声明还会提升到所在块级作用域的头部。 8、ES6的块级作用域允许声明函数的规则只在使用大括号的情况下成立，如果没有使用大括号就会报错。本质上，块级作用域就是一个语句，将多个操作封装在一起，没有返回值。 9、在作用域前面加上do，使称为do表达式。 12345let x=do&#123; let t=f(); t*t+1;&#125;;//在上面代码中，变量x会得到整个块级作用域的返回值。 2.3 const命令10、const声明的常量不得改变值。这意味着，const一旦声明变量，就必须立即初始化，不能能留到以后赋值。 本质：const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）而言，值就保存在变量指向的内存地址中，因此等同于常量。但是对于复合类型的数据（主要是对象和数组），变量指向的内存地址保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，无法控制。因此，将一个对象声明为常量时须小心。 11、Object.freeze方法可以将对象冻结 除了将对象本身冻结，对象的属性也应该冻结 12345678var constanize=(obj)=&gt;&#123; Object.freeze(obj); Object.keys(obj).forEach((key,i)=&gt;&#123; if(typeof obj[key]===&#x27;object&#x27;)&#123; constanize(obj[key]); &#125; &#125;);&#125;; 变量的解构赋值3.1 数组的解构赋值12.ES6允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。 3.2 对象的结构13.结构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值是由它的位置决定的；而对象的属性没有次序，变量必须与属性同名才能取到正确的值。 对象的解构赋值是下面形式的简写 1let&#123;foo:foo,bar:bar&#125;=&#123;foo:&quot;aaa&quot;,bar:&quot;bbb&quot;&#125; 14.对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者。 15.对象的解构可以指定是默认值，默认值生成的条件是，对象的属性值严格等于undefined 16.对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。 1234let &#123;log,sin,cos&#125;=Math;/*** 将Math对象的对数、正弦、余弦三个方法赋值到对应的变量上*/ 3.3 字符串的解构17.类似数组的对象都有一个length属性，因此还可以对这个属性进行解构赋值。 12let &#123;length:len&#125;=&#x27;hello&#x27;len//5 3.4 数值和布尔值的解构赋值18.解构赋值时，如果等号右边的数值和布尔值，则会先转为对象。 12let &#123;toString:s&#125;=123;s===Number.prototype.toString//true 数值和布尔值的包装对象都有toString属性。因此变量s能娶到值。 解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转化为对象，所以无法解构赋值。 3.6 圆括号问题18.三种解构赋值不得使用圆括号 1、变量声明语句 2、函数参数 3、赋值语句的模式 可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用圆括号 3.7 用途1、交换变量的值 [x,y]=[y,x] 2、从函数返回多个值 12345678910111213//返回一个数组function example()&#123; return [1,2,3];&#125;let [a,b,c]=example();//返回一个对象function example()&#123; return &#123; foo:1, bar:2 &#125;;&#125;let &#123;foo,bar&#125;=example(); 3、函数的定义：解构赋值可以方便地将一组参数与变量名对应起来 1234567//参数是一组有次序的值function f([x,y,z])&#123;...&#125;f([1,2,3]);//参数是一组无次序的值function f([x,y,z])&#123;...&#125;f(&#123;z:3,y:2,x:1&#125;); 4、提取JSON数据 5、函数参数的默认值 6、遍历Map解构 任何部署了Iterator接口的对象都可以用for…of…循环遍历。 1234567var map=new Map();map.set(&#x27;first&#x27;,&#x27;hello&#x27;);map.set(&#x27;second&#x27;,&#x27;world&#x27;);//获取键名for(let [key] of map)&#123;&#125;//获取键值for(let [,value] of map)&#123;&#125; 7、输入模块的指定方法 字符串的扩展正则的扩展数值的扩展函数的扩展数组的扩展对象的扩展SymbolSet和Map数据结构 Set类似于数组，但是成员的值是唯一的，没有重复。 Set函数可以接受一个数组（或者一个具有iterable接口的其他数据）作为参数，用来初始化。 向Set加入值时不会发生类型转换。Set内部判断两个值是否相等使用 Same-value-equality ，类似于=== 主要区别在于NaN等于自身，而精确相等不等于。 两个对象总是不相等的 1234567let set =new Set();set.add(&#123;&#125;);set.size;//1set.add(&#123;&#125;);set.size;//2 Set结构的实例有以下属性： Set.prototype.constructor：构造函数，默认就是Set函数 Set.prototype.size：返回Set实例的成员总数 遍历的应用 扩展运算符(…)和Set结构相结合就可以去除数组的重复成员 123let arr=[3,5,2,2,5,5];let unique=[...new Set(arr)];//[3,5,2] * 数组的map和filter方法也可以用于Set 1234567let set=new Set([1,2,3]);set =new Set(...[set].map(x=&gt;x*2));//&#123;2,4,6&#125;let set=new Set([1,2,3,4,5]);set=new Set([...set].filter(x=&gt;(x%2)==0));//&#123;2,4&#125; * Set实现并集、交集、差集 12345678910111213let a=new Set([1,2,3]);let b=new Set([3,4,2]);//并集let union=new Set(...a,...b);//Set &#123;1,2,3,4&#125;//交集let intersect=new Set([...a].filter(x=&gt;b.has(x)));//Set &#123;2,3&#125;let diff=new Set([...a].filter(x=&gt;!b.has(x)))//Set &#123;1&#125; 如果想在遍历操作中同步改变原来Set结构，有两种变通的方法 * 方法一、 12let set=new Set([1,2,3]);set=new Set([...set].map(val=&gt;val*2)); * 方法二、 12let set=new Set&#123;[1,2,3]&#125;;set=new Set(Array.from(set,val=&gt;val*2)); WeakSetWeakSet也是不重复的值的集合，与Set的不同： WeakSet的成员只能是对象 WeakSet中的对象是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。 作为构造函数WeakSet可以接受一个数组或类似数组的对象作为参数。实际上任何具有iterable接口的对象都可以作为WeakSet的参数。 123456789const a=[[1,2],[3,4]];const ws=new WeakSet(a);//WeakSet &#123;[1,2],[3,4]&#125;/** 成为WeakSet的成员的是a数组的成员，而不是a数组本身，这意味着数组的成员只能是对象 */const b=[3,4];const ws=new WeakSet(b);//TypeError//数组b的成员不是对象，因此加入WeakSet就会报错。===&gt; const b=[[3,4]]; WeakSet结构有三个方法 WeakSet.prototype.add(value):向WeakSet实例中添加一个新成员 WeakSet.prototype.delet(value):清除WeakSet实例的指定成员 WeakSet.prototype.has(value):返回一个布尔值，表示某个值是否在WeakSet实例中 WeakSet没有size属性，没有办法遍历成员。因为成员都是弱引用，随时可能消失，遍历机制无法保证成员存在，很可能刚刚遍历结束，成员就取不到了。 1234567891011const foos=new WeakSet();class Foo&#123; constructor()&#123; foos.add(this); &#125; method()&#123; if (!foos.has(this))&#123; throw new TypeError(&#x27;Foo.prototype.method 只能在Foo的实例上使用&#x27;); &#125; &#125;&#125; MapMap共有6种属性：size、set(key,value)、get(key)、has(key)、delete(key)、clear() 共有三种遍历器生成函数和一个遍历方法：keys()、values()、entries()、forEach() JS中的Object本质上就是键值对组合(Hash结构),但是只能是字符串作为键。Map完善Hash结构，提供值-值对应方式。 1234567891011const map=new Map([[&#x27;name&#x27;,&#x27;张三&#x27;],[&#x27;title&#x27;,&#x27;Author&#x27;]]);===&gt;const items=[ [&#x27;name&#x27;,&#x27;张三&#x27;], [&#x27;title&#x27;,&#x27;Author&#x27;]];const map=new Map();items.forEach( (key,value)=&gt;map.set(key,value)); 只有对同一个对象的引用，Map结构才视为同一个键。 123456789const map=new Map();const k1=[&#x27;a&#x27;];const k2=[&#x27;a&#x27;];map.set(k1,111).set(k2,222);map.get(k1)//111map.get(k2)//222 解决同名属性碰撞(clash)问题，如果使用对象作为键名，不用担心属性重名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map就将其视为一个键，包括0和-0。另外虽然NaN不严格等于自身，但Map将其视为一个键。 123456789101112131415let map=new Map();map.set(-0,123);map.get(+0);//123map.set(true,1);map.set(&#x27;true&#x27;,2);map.get(true);//1map.set(undefined,3);map.set(null,4);map.get(undefined);//3map.set(NaN,123);map.get(NaN);//123 set方法返回的是当前的Map对象，链式写法 1234let map&#x3D;new Map().set(1,&#39;a&#39;).set(2,&#39;b&#39;).set(3,&#39;c&#39;); has()方法返回一个布尔值，表示某个值是否在Map数据结构中 遍历方法Map原生提供了3个遍历器生成函数和1个遍历方法 keys()返回键名的遍历器 values()返回键值的遍历器 entries()返回所有成员的遍历器 forEach（）遍历Map的所有成员 Map结构转为数组结构的比较快速的方法是结合扩展运算符(…)。 Map转为数组 1234const myMap=new Map();.set(true,7).set(&#123;foo:3&#125;,[&#x27;abc&#x27;]);[...myMap]//[[true,7],[&#123;foo:3&#125;,[&#x27;abc&#x27;]]] 数组转为Map 12345new Map([[true,7],[&#123;foo:3&#125;,[&#x27;abc&#x27;]]]);//Map&#123;//true=&gt;7,//Object &#123;foo:3&#125;=&gt;[&#x27;abc&#x27;]//&#125; Map转为对象 如果Map的所有键都是字符串，则可以转为对象 123456789101112function strMapToObj(strMap)&#123; let obj=Object.create(null); for(let [k,v] of strMap)&#123; obj[k]=v; &#125; return obj;&#125;const myMap=new Map();.set(&#x27;yes&#x27;,true).set(&#x27;no&#x27;,false)strMapToObject(myMap)//&#123;yes:true,no:false&#125; 对象转为Map 12345678910function objToStrMap(obj)&#123; let strMap&#x3D;new Map(); for(let k of Object.keys(obj))&#123; strMap.set(k,obj[k]); &#125; return strMap;&#125;ObjToStrMap(&#123;yes:true,no:false&#125;)&#x2F;&#x2F;Map &#123;&quot;yes&quot;&#x3D;&gt;true,&quot;no&quot;&#x3D;&gt;false&#125; Map转为JSON 一、Map键名都是字符串=&gt;对象JSON Map=&gt;对象=&gt;JSONfunction 12345function strMapToJson(strMap)&#123;return JSON.stringify(strMapToObj(strMap));&#125;let myMap=new Map().set(&#x27;yes&#x27;,true).set(&#x27;no&#x27;,false);strMapToJson(myMap)//&#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27; 二、键名为非字符串=&gt;数组JSON 1234567function mapToArrayJson(map)&#123; return JSON.stringify([...map])&#125;let myMap=new Map().set(true,7).set(&#123;foo:3&#125;,[&#x27;abc&#x27;]);mapToArrayJson(myMap)//&#x27;[[true,7],[&#123;foo:3&#125;,[&quot;abc&quot;]]]&#x27; JSON转为Map 12345function jsonToStrMap(jsonStr)&#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;)//Map &#123;&#x27;yes&#x27;=&gt;true,&#x27;no&#x27;=&gt;false&#125; WeakMapWeakMap用于解决内存泄漏问题。其键名和所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。 1234567const wm=new WeakMap();let key=&#123;&#125;;let obj=&#123;foo:1&#125;;wm.set(key,obj)obj=null;wm.get(key);//Object &#123;foo:1&#125; 注意：WeakMap弱引用的只是键名而不是键值。键值依然是正常引用的。","categories":[],"tags":[]},{"title":"算法","slug":"算法","date":"2021-04-25T13:53:25.000Z","updated":"2021-05-25T06:25:20.940Z","comments":true,"path":"2021/04/25/算法/","link":"","permalink":"http://example.com/2021/04/25/%E7%AE%97%E6%B3%95/","excerpt":"LeeCode","text":"LeeCode 一、两数之和(哈希表)1234567891011121314151617181920212223/** * 哈希表用法 * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; let len = nums.length; // 创建 MAP const MAP = new Map(); // 由于第一个元素在它之前一定没有元素与之匹配，所以先存入哈希表 MAP.set(nums[0], 0); for (let i = 1; i &lt; len; i++) &#123; // 提取共用 let other = target - nums[i]; // 判断是否符合条件，返回对应的下标 if (MAP.get(other) !== undefined) return [MAP.get(other), i]; // 不符合的存入hash表 MAP.set(nums[i], i) &#125;&#125;; 二、区间内两数反转123456789var reverse = function(x) &#123; let y = parseInt(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)) if(x &lt; 0) &#123; y = -y &#125; return y&gt;2147483647 || y&lt;-2147483647 ? 0 :y&#125;;//parseInt() 函数可解析一个字符串，并返回一个整数。//先将数字转化为String类，再进行翻转操作。 三、回文数1234var isPalindrome = function(x) &#123;let y=parseInt(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));return y===x;&#125;; 四、罗马数字转整数（哈希表）1234567891011121314151617181920212223242526const map = &#123; I : 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000&#125;;let ans = 0;for(let i = 0;i &lt; s.length;) &#123; if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i, i+2)]) &#123; ans += map[s.substring(i, i+2)]; i += 2; &#125; else &#123; ans += map[s.substring(i, i+1)]; i ++; &#125;&#125;return ans; 五、最长公共前缀12345678910111213141516var longestCommonPrefix = function(strs) &#123; if(strs.length == 0) return &quot;&quot;; let ans = strs[0]; for(let i =1;i&lt;strs.length;i++) &#123; let j=0; for(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) &#123; if(ans[j] != strs[i][j]) break; &#125; ans = ans.substr(0, j); if(ans === &quot;&quot;) return ans; &#125; return ans;&#125;; 六、有效的括号(哈希表)12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; let sl = s.length; if (sl % 2) return false; let map = new Map([[&#x27;)&#x27;, &#x27;(&#x27;], [&#x27;]&#x27;, &#x27;[&#x27;], [&#x27;&#125;&#x27;, &#x27;&#123;&#x27;]]); let stack = []; for(let i of s)&#123; if (map.get(i)) &#123; if (stack[stack.length - 1] !== map.get(i)) return false; else stack.pop(); &#125; else &#123; stack.push(i); &#125; &#125; return !stack.length;&#125;; 七、合并两个有序链表（链表）1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) &#123; return l2; &#125; if(l2 == null) &#123; return l1; &#125; if(l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 八、移除元素（双指针）1234567891011var removeElement = function(nums, val) &#123; const n = nums.length; let left = 0; for (let right = 0; right &lt; n; right++) &#123; if (nums[right] !== val) &#123; nums[left] = nums[right]; left++; &#125; &#125; return left;&#125;; 九、删除重复项1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123;let p1 = 0, p2 = 0; while (p2 &lt; nums.length) &#123; if (nums[p1] != nums[p2]) &#123; p1++; nums[p1] = nums[p2]; &#125; p2++; &#125; return p1 + 1;&#125;; 十、实现 strStr()函数12345678910111213141516var strStr = function(haystack, needle) &#123; const n = haystack.length, m = needle.length; for (let i = 0; i + m &lt;= n; i++) &#123; let flag = true; for (let j = 0; j &lt; m; j++) &#123; if (haystack[i + j] != needle[j]) &#123; flag = false; break; &#125; &#125; if (flag) &#123; return i; &#125; &#125; return -1&#125;; 十一、搜索插入位置(easy)123456789var searchInsert = function(nums, target) &#123;for(var i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;=target)&#123; return i; &#125;else if(target&gt;nums[nums.length-1])&#123; return nums.length; &#125;&#125;&#125;; 十二、爬楼梯12345678910/** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function(n) &#123;const sqrt_5 = Math.sqrt(5);const fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2,n + 1);return Math.round(fib_n / sqrt_5);&#125;;//斐波那契数列 1234567891011121314//第二种思路/** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function(n) &#123; const dp = []; dp[0] = 1; dp[1] = 1; for(let i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125;; 十三、买股票最佳时期12345678910111213141516/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let minprice = Number.MAX_SAFE_INTEGER let maxprofit = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minprice) &#123; minprice = prices[i]; &#125; else if (prices[i] - minprice &gt; maxprofit) &#123; maxprofit = prices[i] - minprice; &#125; &#125; return maxprofit;&#125;; 十四、加一12345678910111213141516/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */var plusOne = function(digits) &#123; let a=((BigInt(digits.join(&#x27;&#x27;)))+1n).toString().split(&#x27;&#x27;); return a;&#125;;/*已知传入参数必定为数值型数组将参数转换为字符型（Array.prototype.join()）由字符型变为BigInt型（BigInt构造函数)）进行专属于BigInt类型的数学计算计算结果再次变为字符型（String构造函数）将字符型数值变更为数组（String.prototype.split()）*/ 十五、移动零（双指针）12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let i = 0, j = 0; while (i &lt; nums.length) &#123; if (nums[i] != 0) &#123; [nums[i], nums[j]] = [nums[j], nums[i]]; i++; j++; &#125; else &#123; i++; &#125; &#125;&#125; 十六、数组异或操作12345678 let nums = []; let XOR=0; for (let i = 0; i &lt; n; i++) &#123; nums[i] = start + 2 * i; XOR=XOR^nums[i]; &#125;console.log(XOR);&#125;; 十七、合并两个有序数组123456789101112131415161718192021/***//** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m, nums1.length - m, ...nums2); nums1.sort((a, b) =&gt; a - b)&#125;;/** *splice()向/从数组中添加/删除项目，然后返回被删除的项目。 *与slice()不同，slice会直接对数组进行修改 **/ 十八、数组中的重复数字12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findRepeatNumber = function(arr) &#123; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[i]==arr[j])&#123; return arr[i]; &#125; &#125; &#125;&#125;; 十九、环形链表12345678910111213141516/**给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。如果链表中存在环，则返回 true 。 否则，返回 false 。**/var hasCycle = function(head) &#123; try &#123; JSON.stringify(head) return false &#125; catch &#123; return true &#125;&#125;; 二十、买卖股票的最佳时期Ⅱ123456789101112131415/*给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。*/var maxProfit = function(prices) &#123; let ans = 0; let n = prices.length; for (let i = 1; i &lt; n; ++i) &#123; ans += Math.max(0, prices[i] - prices[i - 1]); &#125; return ans;&#125;; 二十三、对称二叉树1234567891011121314/*给定一个二叉树，检查它是否是镜像对称的。*/var isSymmetric = function(root) &#123; var q = [root, root], n, m while (q.length) &#123; n = q.shift(), m = q.shift() if (!m &amp;&amp; !n) continue if (!m || !n || m.val !== n.val) return false q.push(n.left, m.right, n.right, m.left) &#125; return true&#125;; 二十四、最后一个单词长度12345678910111213141516171819202122232425/*给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。*/var lengthOfLastWord = function(s) &#123; let end = s.length - 1; while(end &gt;= 0 &amp;&amp; s[end] == &#x27; &#x27;) end--; if(end &lt; 0) return 0; let start = end; while(start &gt;= 0 &amp;&amp; s[start] != &#x27; &#x27;) start--; return end - start;&#125;;//初始算法：该算法在验证&quot;a &quot;时出现错误。var lengthOfLastWord = function(s) &#123; s=s.trim();let end=s.length-1,j=0;let s_new=[];while(end&gt;=0 &amp;&amp; s[end]!==&#x27; &#x27;)&#123;s_new[j]=s[end];end--;j++;&#125;return s_new.length;&#125;; 二十五、多数元素1234567891011121314151617181920212223/*** 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。* 你可以假设数组是非空的，并且给定的数组总是存在多数元素。*///方法一：var majorityElement = function(nums) &#123;nums.sort((a,b)=&gt;a-b);return nums[Math.floor(nums.length/2)];&#125;;//方法二：抵消/** 相同的加1, 不相同的减1, 因为是大于一半, 所以最后肯定剩下大于一半的那个*/var majorityElement = function(nums) &#123; let x = 0 let m = 0 for(let n of nums)&#123; if(m === 0) x = n m += x === n ? 1 : -1 &#125; return x&#125;; 二十六、只出现一次的元素（异或）12345678910111213141516/* 异或位运算* 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。4||1 //41||4 //10||4 //41^4 //52^4 //64^4 //0*/var singleNumber = function(nums) &#123; let ans = 0; for(const num of nums) &#123; ans ^= num; &#125; return ans;&#125; 二十七、链表中倒数第k个节点(双指针)12345678910111213141516171819/**输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。*/var getKthFromEnd = function(head, k) &#123; let fast = head; let low = head; let n = 0; while(fast) &#123; fast = fast.next; if(n &gt;= k) &#123; low = low.next; &#125; n++; &#125; return low;&#125; 二十八、二叉树的中序遍历123456789101112131415161718192021222324252627282930313233343536373839/*** 给定一个二叉树的根节点 root ，返回它的 中序 遍历。* 方法一：遍历* 方法二：迭带*///方法一：/*** 定义 inorder(root) 表示当前遍历到 \\textit&#123;root&#125;root 节点的答案，那么按照定义，我们只要递归调用 inorder(root.left) 来遍历 \\textit&#123;root&#125;root 节点的左子树，然后将 \\textit&#123;root&#125;root 节点的值加入答案，再递归调用inorder(root.right) 来遍历 \\textit&#123;root&#125;root 节点的右子树即可，递归终止的条件为碰到空节点**/var inorderTraversal = function(root) &#123; const res = []; const inorder = (root) =&gt; &#123; if (!root) &#123; return; &#125; inorder(root.left); res.push(root.val); inorder(root.right); &#125; inorder(root); return res;&#125;;//方法二：var inorderTraversal = function(root) &#123; const res = []; const stk = []; while (root || stk.length) &#123; while (root) &#123; stk.push(root); root = root.left; &#125; root = stk.pop(); res.push(root.val); root = root.right; &#125; return res;&#125;; 二十九、和为s的连续正整数123456789101112131415161718192021222324252627282930/**输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。*/var findContinuousSequence = function(target) &#123;let end=Math.ceil(target/2);let arr=[];let res=[];let left=0;let right=1;sum=3;for(let i=1;i&lt;=end;i++)&#123; arr.push(i);&#125;while(left&lt;arr.length)&#123;while(sum&lt;target)&#123; right++; sum=0.5*(arr[right]+arr[left])*(right-left+1);&#125;if(sum==target)&#123; res.push(arr.slice(left,right+1));&#125;;left++;right=left+1;sum=0.5*(arr[right]+arr[left])*(right-left+1);&#125;return res;&#125;; 三十、回文链表12345678910/**请判断一个链表是否为回文链表。*/var isPalindrome = function(head) &#123; const vals=[];while(head!=null)&#123; vals.push(head.val); head=head.next;&#125;return vals.join(&#x27;&#x27;)==vals.reverse().join(&#x27;&#x27;);&#125;; 三十一、删除排序链表中的重复元素123456789101112131415161718/*存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。返回同样按升序排列的结果链表。*/var deleteDuplicates = function(head) &#123;if(!head)&#123; return head;&#125;let cur=head;while(cur.next)&#123; if(cur.val===cur.next.val)&#123; cur.next=cur.next.next; &#125;else&#123; cur=cur.next; &#125;&#125;return head&#125;; 三十二、x的平方根1234567891011121314151617181920212223242526/*实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去*/var mySqrt = function(x) &#123; if(x &lt; 0) return NaN; if(x == 0) return 0; let min = 1; let max = x; while(max - min &gt; 1)&#123; let mid = Math.ceil((max + min)/2); if (mid*mid &lt; x ) &#123; min = mid; &#125; else if (mid*mid &gt; x) &#123; max = mid; &#125; else &#123; return mid &#125; &#125;; return min;&#125;; 三十三、替换空格123456789101112/**请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。*/var replaceSpace = function(s) &#123;let arr=s.split(&#x27;&#x27;);for (let i=0;i&lt;arr.length;i++)&#123; if (arr[i]==&#x27; &#x27;)&#123; arr[i]=&#x27;%20&#x27;; &#125;&#125;return (arr.join(&#x27;&#x27;))&#125;; 三十四、相同的树12345678910111213/**给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。*如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。*/var isSameTree = function(p, q) &#123;if(p==null&amp;&amp;q==null)return true;if(p==null ||q==null)return false;if(p.val!=q.val)return false;return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right)&#125;; 三十五、最小的k个数1234567/** 输入整数数组 arr ，找出其中最小的 k 个数。* 例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。*/var getLeastNumbers = function(arr, k) &#123;return arr.sort((a,b)=&gt;(a-b)).slice(0,k);&#125;; 三十六、翻转二叉树123456789var invertTree = function(root) &#123;if(root==null)return null;const Left=invertTree(root.left);const Right=invertTree(root.right);root.left=Right;root.right=Left;return root;&#125;; 三十七、二进制求和1234567/*给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。*/var addBinary = function(a, b) &#123;return (BigInt(&quot;0b&quot;+a)+BigInt(&quot;0b&quot;+b)).toString(2)&#125;; 三十八、反转字符串12345678/**编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。*/var reverseString = function(s) &#123;return s.reverse();&#125;; 三十九、左旋转字符串123456/*字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。*/var reverseLeftWords = function(s, n) &#123;return s.slice(n) + s.slice(0, n);&#125;; 四十、反转链表12345678910111213141516/*定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL*/var reverseList = function(head) &#123;let prev = null; let curr = head; while (curr) &#123; let next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev;&#125;; 四十一、二叉树的最小深度1234567891011121314151617181920212223/*给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。*/var minDepth = function(root) &#123; if(root == null) &#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null) &#123; return 1; &#125; let ans = Number.MAX_SAFE_INTEGER; if(root.left != null) &#123; ans = Math.min(minDepth(root.left), ans); &#125; if(root.right != null) &#123; ans = Math.min(minDepth(root.right), ans); &#125; return ans + 1;&#125;; 四十二、二叉树前序遍历123456789101112131415161718var preorderTraversal = function(root) &#123; return root ? [root.val].concat(preorderTraversal(root.left), preorderTraversal(root.right)) : []&#125;;//栈var preorderTraversal = function(root) &#123; const res = [] const stack = [] if(root) stack.push(root) while (stack.length) &#123; const n = stack.pop() res.push(n.val) if(n.right) stack.push(n.right) if(n.left) stack.push(n.left) &#125; return res&#125;;","categories":[],"tags":[]},{"title":"职工管理系统","slug":"项目/职工管理系统","date":"2021-03-03T01:49:31.000Z","updated":"2021-04-25T13:57:02.717Z","comments":true,"path":"2021/03/03/项目/职工管理系统/","link":"","permalink":"http://example.com/2021/03/03/%E9%A1%B9%E7%9B%AE/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"职工管理系统","text":"职工管理系统 1、管理系统需求公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位以及普通员工职责；完成经理交给的任务 经理职责：完成老板交给的任务，并下发任务给员工 老板职责：管理公司所有事务 管理系统中需要实现的功能如下： 退出管理程序：退出当前管理系统 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号 显示职工信息：显示公司内部所有职工的信息 删除离职员工：按照编号删除指定的员工 修改职工信息：按照编号修改职工个人信息 查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息 按照编号排序：按照职工编号，进行排序，排序规则由用户指定 清空所有文档：清空文件中记录的所有职工信息（清空前需要再次确认，防止误删） 2、创建管理类管理类负责内容如下： 与用户的沟通菜单界面 对职工增删改查的操作 与文件的读写交互 2.1、创建文件5、创建职工类职工的分类为：普通员工、经理、老板 将三种职工抽象到一个类（worker）中，利用多态管理不同的职工种类 职工的属性为：职工编号、职工姓名、职工所在部门编号 职工的行为：岗位指责信息描述、获取岗位名称 头文件文件夹下 创建文件worker.h文件，并且添加如下代码： 1 8、文件交互-写文件功能描述：对文件进行读写 在上一个添加功能中，我们只是将所有的数据添加到内存中，一旦程序结束就无法保存了。 因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作 8.1、设定文件路径在workerManager.h中添加宏常量，并且包含头文件fstream 12#include&lt;fstream&gt;#define FILENAME &quot;empFile.txt&quot; 8.2、成员函数声明在workManager.h中类里添加成员函数 void save() 12&#x2F;&#x2F;保存文件void save(); 9、文件交互-读文件功能描述：将文件中的内容读取到程序中","categories":[],"tags":[]},{"title":"模板","slug":"C++学习/模板","date":"2021-03-01T14:02:16.000Z","updated":"2021-04-25T13:57:41.259Z","comments":true,"path":"2021/03/01/C++学习/模板/","link":"","permalink":"http://example.com/2021/03/01/C++%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E6%9D%BF/","excerpt":"1 模板1.1 模板的概念","text":"1 模板1.1 模板的概念 模板就是建立通用的模具，大大提高复用性 模板的特点：不可以直接使用，她只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思维称为泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板和类模板 1.2.1 函数模板语法作用： 建议一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表 语法： 12template&lt;typename T&gt;函数声明或定义 解释： template–声明创建模板 typename —表明其后面的符号是一种数据类型，可以用class代替 T—通用的数据类型，名称可以替换，通常用大写字母 示例： 1234567891011121314151617181920212223242526272829303132333435363738//交换整型函数void swapInt(int &amp;a,int&amp; b)&#123; int temp=a; a=b; b=temp;&#125;//交换浮点型函数void swapDouble(double &amp;a,double&amp; b)&#123; double temp=a; a=b; b=temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a,T&amp; b)&#123; T temp=a; a=b; b=temp;&#125;void test01()&#123; int a=10; int b=10; //1.利用模板实现交换 //1.自动类型推到 mySwap(a,b); //2.显示指定类型 mySwap&lt;int&gt;(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 函数模板利用关键字template 使用函数模板有两种方式：自动类型推到、显示指定类型 模板的目的是为了提高复用性，将类型参数化。 1.2.2 函数模板的注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T，才可以使用 模板必须要确定出T的数据类型，才可以使用 示例： 12345678910//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a,T&amp; b)&#123; T temp=a; a=b; b=temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T，才可以使用","categories":[],"tags":[]},{"title":"文件操作","slug":"C++学习/文件操作","date":"2020-12-19T08:30:43.000Z","updated":"2020-12-19T12:48:56.888Z","comments":true,"path":"2020/12/19/C++学习/文件操作/","link":"","permalink":"http://example.com/2020/12/19/C++%E5%AD%A6%E4%B9%A0/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件","text":"文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 文件类型分为两种： 文本文件 - 文件以文本的ASCⅡ码形式存储再计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂 操作文件的三大类： ofstream : 写操作 ifstream : 读操作 fstream : 读写操作 1、文本文件1.1 写文件写文件步骤如下： 包含头文件 #include&lt;fstream&gt; 创建流对象 ofstream ofs 打开文件 ofs.open(&quot;文件路径&quot;，打开方式) 写数据 ofs&lt;&lt;&quot;写入的数据&quot;; 关闭文件 ofs.close(); 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意：文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios::out 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;void test01()&#123; //1、包含头文件 fstream //2、创建流对象 ofstream ofs; //3、指定打开的方式 ofs.open(&quot;test.txt&quot;,ios::out); //4、写内容 ofs &lt;&lt; &quot;姓名:张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：nan&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; //5、关闭文件 ofs.close();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 文件操作必须包含头文件fstream 读文件可以利用ofstream，或者fstream类 打开文件时需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 1.2 读文件 读文件可以利用ifstream，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 2、二进制文件以二进制的方式对文件进行读写 打开方式ios::binary 2.1 写文件二进制方式写文件主要利用流对象常规能源函数write 函数类型：ostream&amp; write(const char * butter,int len); 参数解释：字符指针buffer指向内存中一段存储空间","categories":[],"tags":[]},{"title":"第10章-类和对象","slug":"C++学习/类和对象","date":"2020-12-04T02:27:28.000Z","updated":"2021-03-01T13:58:05.751Z","comments":true,"path":"2020/12/04/C++学习/类和对象/","link":"","permalink":"http://example.com/2020/12/04/C++%E5%AD%A6%E4%B9%A0/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"类和对象C++ 面向对象：封装、继承、多态 C++认为万事万物皆为对象，对象上有其属性和行为","text":"类和对象C++ 面向对象：封装、继承、多态 C++认为万事万物皆为对象，对象上有其属性和行为 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 语法：class 类名{ 访问权限：属性 / 行为 }; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324const double PI = 3.14;class Circle&#123; //访问权限 //公共权限 public: //属性 //半径 int m_r; //行为 //获取圆的周长 double calculateZC() &#123; return 2 * PI* m_r; &#125;&#125;;int main()&#123; Circle c1; c1.m_r=10; cout&lt;&lt;&quot;圆的周长： &quot;&lt;&lt;c1.calculateZC()&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 封装的意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 成员在类内可以访问，类外可以访问 protected 保护权限 成员类内可以访问，类外不可以访问 private 私有权限 成员类内可以访问，类外不可以访问 实例： 123456789class Person&#123; public: string m_Name; protected: string m_Car; private: int m_Password;&#125; 4.1.2 struct和class区别在C++中struct和class唯一的区别就在于默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 123456789101112131415161718class C1&#123; int m_A;//默认是私有权限&#125;;struct C2&#123; int m_A;&#125;;int main()&#123; C1 c1; c1.m_A = 10;//错误，访问权限是私有 C2 c2; c2.m_A = 10 ;//正确，访问权限时公共 system(&quot;pause&quot;); return 0;&#125; 4.1.3 成员属性设为私有优点一：将所有成员属性设置为私有，可以自己控制读写权限 优点二：对于写权限，可以检测数据的有效性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123;public: //姓名设置为可读可写 void setName(string name)&#123; m_Name=name; &#125; string getName() &#123; return m_Name; &#125; //获取年龄 int getAge()&#123; return m_age; &#125; //设置年龄 void setAge(int age)&#123; if (age &lt; 0 || age &gt;150)&#123; cout&lt;&lt;&quot;超载&quot;&lt;&lt;endl; return; &#125; m_age=age; &#125; //情人设置为只写 void setLover(string lover)&#123; m_Lover=lover; &#125;private: string m_Name;//只读可写 姓名 int m_Age;//只读 年龄 string m_Lover; 只写 情人&#125;;int main()&#123; Person p; //姓名设置 p.setName(&quot;张三&quot;); cout&lt;&lt;&quot;姓名： &quot;&lt;&lt;p.getName()&lt;&lt;endl; //年龄设置 p.setAge(50); cout&lt;&lt;&quot;年龄： &quot;&lt;&lt;p.getAge()&lt;&lt;endl; //情人设置 p.srtLover(&quot;苍进&quot;); system(&quot;pause&quot;); return 0;&#125; 练习案例： 设计立方体类 求出立方体面积和体积 分别用全局函数和成员函数判断两个立方体是否相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;class Cube&#123;public: //长 void setL(int l) &#123; m_L = l; &#125; int getL() &#123; return m_L; &#125; //宽 void setW(int w) &#123; m_W = w; &#125; int getW() &#123; return m_W; &#125; //高 void setH(int h) &#123; m_H = h; &#125; int getH() &#123; return m_H; &#125; int calculateS() &#123; return 2 * m_H*m_L + 2 * m_H*m_W + 2 * m_L*m_W; &#125; int calculateV() &#123; return m_H * m_L*m_W; &#125;private: int m_L;//长 int m_W; int m_H;&#125;;bool isSame(Cube &amp;c1, Cube &amp;c2)&#123; if (c1.getL() == c2.getL() &amp;&amp; c1.getH() == c2.getH() &amp;&amp; c1.getW() == c2.getW()) &#123; return true; &#125; return false;&#125;int main() &#123; Cube c1; c1.setH(10); c1.setL(10); c1.setW(10); std::cout &lt;&lt; &quot;面积： &quot; &lt;&lt; c1.calculateS() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;体积： &quot; &lt;&lt; c1.calculateV() &lt;&lt; std::endl; Cube c2; c2.setH(20); c2.setL(20); c2.setW(20); bool ret = isSame(c1, c2); if (ret) &#123; std::cout&lt;&lt;&quot;c1和c2一致&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;不一致&quot;; &#125; system(&quot;pause&quot;); return 0;&#125; 4.2 对象的初始化和清理 生活中我们的电子产品基本都会有出厂设置，在某一天不用的时候会删除一些信息保证安全 C++中面向对象源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置 不能在类声明中初始化静态成员变量 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果未知。 ​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。 C++利用构造函数和析构函数解决上述问题，这两个函数会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void。 函数名与类名相同。 构造函数可以有参数，因此可以发生重载。 程序在调用对象的时候会自动调用构造，无需手动调用，而且只会调用一次。 析构函语法数：~类名()&#123;&#125; 析构函数，没有返回值也不写void。 函数名称与类名相同，在名称前加符号 ~ 析构函数不可以有参数，因此不可以发生重载。 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次。 什么时候调用析构函数： 如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用 如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用 如果对象通过new创建，则它将驻留在栈内存或自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用 程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象使用时自动调用其析构函数 1stock1 = Stock(&quot;Nity Foods&quot;,10,50.0)//在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象 1234567891011121314151617181920212223class Person&#123;public: //构造函数 Person() &#123; cout&lt;&lt;&quot;Person 的构造函数调用&quot;&lt;&lt;endl; &#125; //析构函数 ~Person() &#123; cout&lt;&lt;&quot;Person的析构函数调用&quot;&lt;&lt;endl; &#125;&#125;;void test01()&#123; Person P;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.2 构造函数的分类与调用两种分类方式： ​ 按参数分为：有参构造和无参构造 ​ 按类型分为：普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//1.构造函数分类// 按照参数分类为 有参和无参构造 无参又称为默认构造函数// 按照类型分为 普通构造和拷贝构造class Person&#123;public: //无参（默认）构造函数 Person()&#123; cout&lt;&lt;&quot;无参构造函数！&quot;&lt;&lt;endl; &#125; //有参构造函数 Person(int a)&#123; age = a; cout&lt;&lt;&quot;有参构造函数&quot;&lt;&lt;endl; &#125; //拷贝构造函数 Person(const Person &amp; P)&#123; age = p.age; cout&lt;&lt;&quot;拷贝构造函数!&quot;&lt;&lt;endl; &#125; //析构函数 ~Person()&#123; cout&lt;&lt;&quot;析构函数&quot;&lt;&lt;endl; &#125; int age;&#125;;//2.构造函数调用//调用无参构造函数void test01()&#123; Person p;//调用无参构造函数&#125;//调用有参的构造函数void test01()&#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器会认为这是一个函数声明 //Person p2(); //2.2 显示法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10;//Person p4 = Person(10); Person p5 = p4;//Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //person p5(p4);&#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 4.2.4 构造函数调用规则默认情况下，C++编译器至少给一个类添加3个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数 C++不再提供默认无参构造 但会提供默认拷贝构造 如果用户定义拷贝构造函数 c++不会再提供其他构造函数 4.2.5 深拷贝和浅拷贝浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;//深拷贝与浅拷贝问题class Person &#123;public: Person() &#123; cout &lt;&lt; &quot;Person 的默认构造函数&quot; &lt;&lt; endl; &#125; Person(int a, int heigth) &#123; m_age = a; cout &lt;&lt; &quot;Person 的有参构造函数&quot; &lt;&lt; endl; m_Height = new int(heigth); &#125; //自己实现拷贝构造函数 解决浅拷贝带来的问题 Person(const Person &amp;p) &#123; cout &lt;&lt; &quot;Person拷贝构造函数调用&quot; &lt;&lt; endl; m_age = p.m_age; m_Height = new int(*p.m_Height); &#125; ~Person() &#123; //析构代码，将堆区开辟数据做释放操作 if (m_Height !=NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person 的析构函数&quot; &lt;&lt; endl; &#125; int m_age; int * m_Height;&#125;;void test01() &#123; Person p1(10,160); cout &lt;&lt; &quot;p1的年龄为： &quot; &lt;&lt; p1.m_age &lt;&lt; endl; cout &lt;&lt; &quot;P1的身高为： &quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;P2的年龄为: &quot; &lt;&lt; p2.m_age &lt;&lt; endl; cout &lt;&lt; &quot;P2的身高为: &quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。 4.2.6 初始化列表作用：C++提供了初始化列表，用来初始化属性 语法：构造函数():属性1（值1），属性2（值2）...&#123;&#125; 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//初始化列表class Person &#123;public: //传统用法： // Person(int a,int b,int c) &#123; // m_A = a; // m_B = b; // m_C = c; // &#125; Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123; &#125; void test01() &#123; cout &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; m_C &lt;&lt; endl; &#125;private: int m_A; int m_B; int m_C;&#125;;int main() &#123; Person p(50, 60, 70); p.test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为对象成员。 例如： 1234class A&#123;&#125;class B&#123; A a;&#125; B类中有对象A作为成员，A为对象成员 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//类对象作为类成员class phone &#123;public: phone(string pName) &#123; m_PName = pName; &#125; //手机名字 string m_PName;&#125;;class Person &#123;public: Person(string name, string pName):m_Name(name),m_phone(pName) &#123; &#125; //姓名 string m_Name; //手机 phone m_phone;&#125;;void test01() &#123; Person p(&quot;张三&quot;, &quot;IphoneMax&quot;); cout &lt;&lt; p.m_Name &lt;&lt; endl; cout &lt;&lt; p.m_phone.m_PName &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.8 静态成员就是在成员变量和成员函数前加上关键词static，称为静态成员静态成员分为： 静态成员变量 所有对象共享一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享一个函数 静态成员函数只能访问静态成员变量 示例1：静态成员变量 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;//静态成员变量class Person &#123;public: //1. 所有对象共享同一份数据 //2. 编译阶段就分配内存 //3. 类内声明，类外初始化操作 static int m_A; //静态成员变量也有访问权限private: static int m_B;&#125;;int Person::m_A = 100;int Person::m_B = 200;void test01() &#123; Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; p.m_A &lt;&lt; endl;&#125;void test02() &#123; //静态成员变量 不属于某个对象上，所有对象都共享同一份数据 //因此静态成员变量有两种访问方式 //1.通过对象进行访问 Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; //2.通过类名进行访问 cout &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; Person::m_B &lt;&lt; endl;//类外访问不到私有变量&#125;int main1() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;//静态成员函数//所有对象共享同一个函数//静态成员函数只能访问静态成员变量class Person &#123;public: static void func() &#123; //m_B=200 静态成员函数 不可以访问 非静态成员变量 无法区分到底是哪个对象的m_B m_A = 0;//静态成员函数可以访问 静态成员变量 cout &lt;&lt; &quot;static void func()调用&quot; &lt;&lt; endl; &#125; static int m_A; int m_B; //静态成员函数也有访问权限private: static void func2() &#123; cout &lt;&lt; &quot;static void func2()函数&quot;&lt;&lt;endl; &#125;&#125;;int Person::m_A = 100;//有两种访问方式void test01() &#123; Person p; p.func(); // Person::func();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;//成员变量 和 成员函数 分开存储class Person &#123; int m_A;//非静态成员变量 属于类的对象上 static int m_B;//静态成员变量 不属于类对象上 void func() &#123;&#125;//非静态成员函数 不属于类的对象上 static void func2()&#123;&#125; //静态成员函数 不属于类的对象上&#125;;void test01() &#123; Person p; //空对象占用空间为：1 //C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 //每个空对象也应该有一个独一无二的内存地址 cout &lt;&lt; &quot;内存空间为：&quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;void test02() &#123;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 4.3.2 this指针概念通过上文知道C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可用return *this。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class Person &#123;public: Person(int age) &#123; //this指针指向 被调用的成员函数所属的对象 this-&gt;age = age; &#125; Person &amp; Personaddage(Person &amp;p) &#123; this-&gt;age += p.age; return *this; &#125; int age;&#125;;//1. 解决名称冲突void test01() &#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt;p1.age&lt;&lt;endl;&#125;//2.返回对象本身*thisvoid test02() &#123; Person p1(10); Person p2(10); //p2.Personaddage(p1); //链式编程思想 p2.Personaddage(p1).Personaddage(p1).Personaddage(p1); cout &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 4.3.3空指针访问成员函数C++中空指针也可以调用成员函数，但也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//空指针调用成员函数class Person &#123;public: void showClassname() &#123; cout &lt;&lt; &quot;this is Person Class&quot; &lt;&lt; endl; &#125; void showPersonage() &#123; //报错原因因为传入的指针是NULL if (this == NULL) &#123; return; &#125; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_age &lt;&lt; endl; &#125; int m_age;&#125;;void test01() &#123; Person * p = NULL; p-&gt;showClassname(); p-&gt;showPersonage();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后称这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键词mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class Person &#123;public: //this指针的本质 是指针常量 指针的指向是不可以修改的 //Person * const this; //在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改 void showPerson() const &#123; this-&gt;m_B = 100; //m_A = 100; //this=NULL;//this指针不可以修改指针的指向的 &#125; void func() &#123;&#125; int m_A; mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个,加关键词mutable&#125;;//常对象void test02() &#123; const Person p;//在对象前加const,变为常对象 //常对象只能调用常函数 p.showPerson(); //p.func();//常对象不可以调用普通成员函数，因为普通成员函数可以修改属性&#125;int main() &#123; system(&quot;pause&quot;); return 0;&#125; 4.4 友元友元的目的就是让一个一个函数或者类访问另一个类中私有成员 友元的关键词为 friend 创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键词friend ** 友元函数与成员函数之间的区别： 成员函数是类定义的一部分，通过特定的对象来调用。成员函数可以隐式访问调用对象的成员，而无需使用成员运算符。友元函数不是类的组成部分，因此被称为直接函数调用。友元函数不能隐式访问成员，而必须将成员运算符作为传递的对象。 友元的三种实现： 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//建筑物类class Building&#123; //goodGuy全局函数是Building好朋友，可以访问Building中私有成员 friend void goodGuy(Building * b);public: Building() &#123; m_SittingRoom = &quot;客厅&quot;; m_Bedroom = &quot;卧室&quot;; &#125;public: string m_SittingRoom;private: string m_Bedroom;&#125;;//全局函数void goodGuy(Building * b) &#123; cout &lt;&lt; &quot;好基友全局函数 正造访问：&quot; &lt;&lt; b-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友全局函数 正造访问：&quot; &lt;&lt; b-&gt;m_Bedroom&lt;&lt; endl;&#125;void test01() &#123; Building b; goodGuy(&amp;b);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4.2 类做友元1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building;class GoodGuy &#123;public: GoodGuy(); void visit(); Building * b;&#125;;class Building &#123; //GoodGuy类是本来的好朋友，可以访问本类中私有成员 friend class GoodGuy;public: Building();public: string m_SittingRoom;private: string m_BedRoom;&#125;;//类外写成员函数Building::Building() &#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy() &#123; //创建建筑物对象 b = new Building;//在堆区创建一个对象&#125;void GoodGuy::visit() &#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; b-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; b-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01() &#123; GoodGuy gg; gg.visit();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 类的友元函数是非成员函数，因此不能使用成员运算符来调用；其访问权限与成员函数相同。 4.4.3 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Building;class GoodGuy &#123;public: GoodGuy(); void visit();//该函数可以访问Building中私有成员 void visit2();//该函数不可以访问Building中私有成员 Building * b;&#125;;class Building&#123; friend void GoodGuy::visit();//告诉编译器 GoodGuy类下的visit成员作为本类的好朋友，可以访问私有成员public: Building();public: string m_SittingROOM;//客厅private: string m_BedRoom;//卧室&#125;;//类外实现成员函数Building::Building() &#123; m_SittingROOM = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy()&#123; b = new Building;&#125;void GoodGuy::visit() &#123; cout &lt;&lt; &quot;visit 函数正在访问： &quot; &lt;&lt; b-&gt;m_SittingROOM &lt;&lt; endl; cout &lt;&lt; &quot;visit 函数正在访问： &quot; &lt;&lt; b-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGuy::visit2() &#123; cout &lt;&lt; &quot;visit2 函数正在访问： &quot; &lt;&lt; b-&gt;m_SittingROOM &lt;&lt; endl;&#125;void test01() &#123; GoodGuy gg; gg.visit(); gg.visit2();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;//加号运算符重载class Person &#123;public: //1、成员函数重载 + 号// Person operator+(Person &amp;p) &#123;// Person temp;// temp.m_A = this-&gt;m_A + p.m_A;// temp.m_B = this-&gt;m_B + p.m_B;// return temp;// &#125; int m_A; int m_B;&#125;;//2、全局函数重载 + 号Person operator+(Person &amp;p1, Person &amp;p2)&#123; Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp;&#125;void test01() &#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 10; p2.m_B = 10; //成员函数重载本质调用 //Person p3 = p1.operator+(p2); //全局函数重载本质调用 //Person p3 = operator+(p1, p2); Person p3 = p1+p2; cout &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结一：对于内置的数据类型的表达式的运算符是不可能改变的 总结二：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//左移运算符重载class Person &#123; friend ostream &amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p); //利用成员函数重载 左移运算符 不会利用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧public: Person(int a, int b) &#123; m_A = a; m_B = b; &#125;private: int m_A; int m_B;&#125;;//只能利用全局函数重载左移运算符ostream &amp; operator&lt;&lt;(ostream &amp;cout, Person &amp;p) &#123; cout &lt;&lt; p.m_A &lt;&lt; &quot; &quot; &lt;&lt; p.m_B &lt;&lt; endl; return cout;&#125;void test01() &#123; Person p(10,10); //p.m_A = 10; //p.m_B = 10; cout &lt;&lt; p &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符作用：通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class MyInteger &#123;friend ostream &amp; operator&lt;&lt;(ostream &amp; cout,MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //重载前置++运算符 返回引用为了一直对一个数据进行递增操作 MyInteger &amp; operator++() &#123; m_Num++; return *this; &#125; //重载后置++运算符 MyInteger operator++(int) //int代表占位参数，可以用于区分前置和后置递增 &#123; MyInteger temp = *this; m_Num++; return temp; &#125;private: int m_Num;&#125;;ostream &amp; operator&lt;&lt;(ostream &amp; cout, MyInteger myint)&#123; cout &lt;&lt; myint.m_Num; return cout;&#125;void test01() &#123; MyInteger myint; cout &lt;&lt; ++(++myint) &lt;&lt; endl; cout &lt;&lt; myint &lt;&lt; endl;&#125;void test02() &#123; MyInteger myint; cout &lt;&lt; myint++ &lt;&lt; endl; cout &lt;&lt; myint &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：前置递增返回引用，后置递增返回值。 4.5.4 赋值运算符重载C++编译器至少给一个类添加4个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性进行值拷贝 赋值运算符operator=，对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作也会出现深浅拷贝操作问题。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;//赋值运算符重载class Person &#123;public: Person(int age) &#123; m_Age = new int(age); &#125; int *m_Age; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //重载赋值运算符 Person &amp;operator = (Person &amp;p) &#123; //编译器是提供浅拷贝 //m_Age=p.m_Age; //应先判断是否有属性在堆区，如有先释放干净，然后再深拷贝 if (m_Age!=NULL) &#123; delete m_Age; m_Age = NULL; &#125; m_Age = new int(*p.m_Age); return *this;//return *this 返回的是对象，return this 返回的是地址 &#125;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p1 = p2; cout &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name , int age) &#123; m_Name = name; m_Age = age; &#125; //重载== bool operator==(Person &amp;p) &#123; if (this-&gt;m_Name==p.m_Name &amp;&amp; this-&gt;m_Age==p.m_Age) &#123; return true; &#125; return false; &#125; string m_Name; int m_Age;&#125;;void test01() &#123; Person p1(&quot;Tom&quot;, 18); Person p2(&quot;Jom&quot;, 18); if (p1==p2) &#123; cout &lt;&lt; &quot;两个相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符()也可以重载 由于重载后使用方式非常像函数的调用，因此称为仿函数 仿函数没有固定的写法，非常灵活。 示例： 123456789101112131415161718192021222324252627282930313233343536class MyPint&#123;public: void operator()(string text) &#123; cout&lt;&lt;test&lt;&lt;endl; &#125;&#125;;void test01()&#123; //重载的()操作符 也称为仿函数 MyPint myFunc; myFunc(&quot;hello world!&quot;);&#125;class Myadd&#123;public: int operator()(int v1,int v2) &#123; return v1+v2; &#125;&#125;;void test02()&#123; Myadd add; int ret=add(10,10) cout&lt;&lt;ret&lt;&lt;endl; //匿名对象调用 cout&lt;&lt;Myadd()(100,100)&lt;&lt;endl;&#125;int main()&#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 重载运算符的规则如下： C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载； C++不能重载的运算符只有5个； 重载不能改变运算对象的个数； 重载不能改变运算符的优先级和结合性； 重载运算符的函数不能有默认的参数； 重载的运算符必须和用户定义的自定义类型的对象一起使用，至少应有一个是类对象，即不允许参数全部是C++的标准类型。 4.6 继承4.6.1 基本语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;//继承实现页面//公共页面class BasePage&#123;public: void header() &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; &#125;&#125;;//继承好处：减少重复代码//语法：class 子类 : 继承方式 父类//子类也称派生类 //父类称为基类//Java页面class Java :public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;Java&quot;&lt;&lt;endl; &#125;&#125;;//c++页面class Cpp :public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python :public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;Python&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Java页面&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.content(); cout &lt;&lt; &quot;______________________&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++页面&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.content(); cout &lt;&lt; &quot;________________________________&quot; &lt;&lt; endl; cout &lt;&lt; &quot;python页面&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.content();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 派生类中的成员，包括两大部分 一类是从基类继承过来的，一类是自己增加的成员 从基类继承过来的表现其共性，而新增的成员体现个性。 4.6.2 继承方式继承的语法：class 子类 ： 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 保护权限在类外访问不到 4.6.3 继承中的对象模型 父类中所有非静态成员属性都会被子类继承下去 父类中私有成员属性 是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了 利用开发人员命令提示工具查看对象模型 跳转盘符 D: 跳转文件路径 cd 具体路径下 查看命名 cl /d1 reportSingleClassLayout类名 文件名 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Base &#123;public: Base() &#123; cout &lt;&lt; &quot;Base构造函数&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base析构函数&quot; &lt;&lt; endl; &#125;&#125;;class son : public Base &#123;public: son() &#123; cout &lt;&lt; &quot;Son搞糟函数&quot; &lt;&lt; endl; &#125; ~son() &#123; cout &lt;&lt; &quot;Son析构函数&quot; &lt;&lt; endl; &#125;&#125;;void test01() &#123; //Base b; //继承中的构造和析构顺序如下： //先构造父类，再构造子类，析构的顺序与构造的顺序相反 son s;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.6.5 继承同名成员处理方式 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 12345678910111213141516171819202122232425262728293031323334353637383940414243class Base&#123;public: Base() &#123; m_A=100; &#125; void func()&#123; cout&lt;&lt;&quot;Base-func()调用&quot;&lt;&lt;endl; &#125; void func(int a) &#123; cout&lt;&lt;&quot;Base-func(int a)调用&quot;&lt;&lt;endl; &#125; public: int m_A;&#125;;class Son : public Base&#123;public: Son()&#123; m_A=20; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func()&#123; cout&lt;&lt;&quot;Son-func()调用&quot;&lt;&lt;endl; &#125;public: int m_A;&#125;;void test01()&#123; Son s; cout&lt;&lt;s.m_A&lt;&lt;endl; cout&lt;&lt;s.Base::m_A&lt;&lt;endl; s.func(); s.Base::func(); s.Base::func(10);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 子类对象可以直接访问到子类中同名函数 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中的同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式静态成员和非静态成员出现同名，处理方式一致 访问子类同名 直接访问即可 访问父类同名 需要加作用域 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和用过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法：class 子类 : 继承方式 父类1， 继承方式 父类2... 多继承可能引发父类中有同名成员出现，需要加作用域区分 C++开发中不建议使用多继承 4.6.8 菱形继承菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形类，或者钻石继承 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class Animal&#123;public: int m_Age;&#125;;//利用虚继承 解决菱形继承的问题//在继承之前 加上关键词 virtual 变为虚基类//Animal类称为 虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal&#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01() &#123; SheepTuo st; st.Tuo::m_Age = 18; st.Sheep::m_Age = 28; cout &lt;&lt; &quot;Tuo:&quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;Sheep:&quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象的三大特性之一 多态分为两类 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 -运行阶段确定函数地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;class Animal&#123;public: //虚函数 virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: //重写：函数返回值 函数名 参数列表 完全相同 virtual void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;//地址早绑定 在编译阶段就确定函数函数地址//如果想让猫说话 这个函数地址不能提前绑定 需要在运行阶段绑定 地址晚绑定//动态多态满足条件//1、有继承关系//2、子类重写父类的虚函数//动态多态使用//父类的指针或者引用 执行子类对象void doSpeak(Animal &amp; a)&#123; a.speak();&#125;void test01()&#123; Cat c; doSpeak(c);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.2 多态案例1：计算器类多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展及维护 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;class Calculator&#123;public: virtual int GetResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//class Addresult : public Calculator &#123;public: int GetResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//class Subresult : public Calculator&#123;public: int GetResult() &#123; return m_Num1 - m_Num2; &#125;&#125;;void test01()&#123; //父类的指针或引用指向子类对象 Calculator * abc = new Addresult; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 100; cout &lt;&lt;abc-&gt;m_Num1&lt;&lt;&quot;+&quot;&lt;&lt;abc-&gt;m_Num2&lt;&lt;&quot;=&quot;&lt;&lt; abc-&gt;GetResult() &lt;&lt; endl; //用完释放 delete abc; abc = new Subresult; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 50; cout &lt;&lt; abc-&gt;GetResult()&lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法 virtual 返回值类型 函数名 （参数列表） = 0 当类中有了纯虚函数，这个类也称为抽象类 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1、无法实例化对象 //2、抽象类的子类 必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class son : public Base &#123;public: void func() &#123; cout &lt;&lt; &quot;调用func()函数&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Base * abc = new son; abc-&gt;func();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.4 多态案例二 -制作饮品1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;using namespace std;class AbstractDrinking&#123;public: //煮水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; void makeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;class Coffee : public AbstractDrinking&#123;public: void Boil() &#123; cout &lt;&lt; &quot;煮水&quot; &lt;&lt; endl; &#125; void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl; &#125; void PourInCup() &#123; cout &lt;&lt; &quot;导入&quot; &lt;&lt; endl; &#125; void PutSomething() &#123; cout &lt;&lt; &quot;加入糖类&quot; &lt;&lt; endl; &#125;&#125;;class Tea : public AbstractDrinking&#123;public: void Boil() &#123; cout &lt;&lt; &quot;煮水&quot; &lt;&lt; endl; &#125; void Brew() &#123; cout &lt;&lt; &quot;冲泡茶水&quot; &lt;&lt; endl; &#125; void PourInCup() &#123; cout &lt;&lt; &quot;导入&quot; &lt;&lt; endl; &#125; void PutSomething() &#123; cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl; &#125;&#125;;//制作函数 公共接口void doWork(AbstractDrinking * abs) &#123; abs-&gt;makeDrink(); delete abs;&#125;void test01()&#123; doWork(new Coffee); doWork(new Tea);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名()=0; 类名：：~类名（）&#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Animal&#123;public: Animal() &#123; cout &lt;&lt; &quot;Animal构造函数调用&quot; &lt;&lt; endl; &#125; //利用虚析构可以解决 父类指针释放子类对象时不干净的问题 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal析构函数调用&quot; &lt;&lt; endl; //&#125; //纯虚析构 需要声明也需要实现 //有了纯虚函数之后，这个类也属于抽象类，无法实例化对象 virtual ~Animal() = 0; //纯虚函数 virtual void speak() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal纯虚析构函数调用&quot; &lt;&lt; endl; &#125;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name);//在堆区创建了一个属性 &#125; virtual void speak() &#123; cout &lt;&lt;&quot;The cat named &quot;&lt;&lt;*m_Name &lt;&lt;&quot; is saying&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal * a = new Cat(&quot;Tom&quot;); a-&gt;speak(); //父类指针在析构时候，不会调用子类中析构函数，导致子类如果有堆区属性，出现内存泄漏 delete a;//把指针释放&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 如果子类中没有堆区数据，可以不写为虚析构或纯虚构 拥有纯虚析构函数的类也属于抽象类 4.7.6 电脑组装案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;iostream&gt;using namespace std;//抽象不同零件类//抽象CPUclass CPU&#123;public: //抽象计算函数 virtual void calculate() = 0;&#125;;//抽象显卡class VideoCard&#123;public: //抽象显示函数 virtual void display() = 0;&#125;;//抽象内存条class Memory&#123;public: //抽象存储函数 virtual void storage() = 0;&#125;;//电脑class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU * m_cpu; VideoCard * m_vc; Memory * m_mem;&#125;;//具体厂商//Intelclass IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;IntelCPU开始计算了&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel显卡开始计算了&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel内存条开始计算了&quot; &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;LenovoCPU开始计算了&quot; &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo显卡开始计算了&quot; &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo内存条开始计算了&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //创建第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; //组装二台电脑 Computer * computer2 = new Computer(new LenovoCPU,new LenovoVideoCard,new LenovoMemory); computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; //组装三台电脑 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory); computer3-&gt;work(); delete computer3;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"第四章-复合类型部分","slug":"C++学习/复合类型","date":"2020-11-30T14:25:59.000Z","updated":"2020-12-02T07:36:37.407Z","comments":true,"path":"2020/11/30/C++学习/复合类型/","link":"","permalink":"http://example.com/2020/11/30/C++%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"复合类型重点摘录： 要创建数组，可使用声明语句。数组声明应指出三点： ①. 存储在每个元素中的值的类型","text":"复合类型重点摘录： 要创建数组，可使用声明语句。数组声明应指出三点： ①. 存储在每个元素中的值的类型 ​ ②. 数组名 ​ ③. 数组中的元素数 ​ 声明数组的通用格式如下： 1typeName arrayName[arraySize] 其中所有的值在编译时都是已知的，具体地说，arraySize不能是变量。 数组的初始化规则 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组。然而，可以使用下标分别给数组中的元素赋值。 初始化数组时，提供的值可以少于数组的元素数目。 如果初始化数组时方括号内[]为空，C++编译器将计算元素个数。 C++11新增功能： 初始化数组时，可省略（=)。 1double earning[4] &#123;1.2e4,1.6e4,1.1e4,1.7e4&#125;; 可不在大括号内包含任何东西，这将把所有元素都设置为零。 列表初始化禁止缩窄转换。 字符串 只需使用一个用引号括起的字符串即可，这种字符串被称为字符串常量或字符串字面值 12char bird[11]=&quot;Mr.Cheeps&quot;;char fish[]=&quot;Bubbles&quot;; 用引号括起来的字符串隐式地包括结尾的字符串，因此不用显式地包括它。将字符串读入到char数组中，将自动加上结尾地空字符。 在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。 字符串常量（” “）与不能与字符常量(‘ ‘)互换。‘S’表示83的另一种写法（ASCⅡ系统）。“S”表示两个字符（S和\\0）组成的字符串，实际上表示的是字符串所在的内存地址。 sizeof运算符指出整个数组的长度，strlen()函数返回的是存储在数组中的字符串长度，只计算可见的字符，而不把空字符计算在内。 cin使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词。 面向行的输入：getline() getline()函数读取整行，通过回车键输入的换行符来确定输入结尾，getline()会丢弃换行符。get()将换行符保留在输入序列中。 面向行的输入：get() 换行符将留在队列中，使用不带任何参数的cin.get()调用可读取下一个字符（即使是换行符） 另一种使用get()的方式是将两个类成员函数拼接起来，如下所示： 1cin.get(name,AeSize).get(); 当get()读取空行后将设置失效位(failbit)。这意味着接下来的输入将被阻断，但可以输入命令回复输入： 1cin.clear(); 混合输入数字和面向行的字符串会导致问题：cin在读取数字时，将回车键生成的换行符留在了输入队列中。后面的getling()看到换行符后，将认为是一个空行，并将一个空字符串赋给address数组。 要使用string类，必须在程序中包含头文件string。string类位于名称空间std中，必须使用std::string来引用。string类定义隐藏了字符串的数组性质。 string对象和字符数组之间的主要区别是，可以将string对象声明为简单变量，而不是数组，类设计让程序能够自动处理string大小。 不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。 可以使用运算符+将两个对象合并起来，还可以使用运算符+=将字符串附加到string对象的结尾。 使用函数strcpy()将字符串复制到字符数组中，使用函数strcat()将字符串附加到字符数组末尾。 12strcpy(charr1,charr2);//copy charr2 to charr1strcat(charr1,charr2);//append contents of charr2 to charr1 C++允许在声明结构变量时省略关键词const。 注意：在声明struct时，用;隔开 ​ 在使用结构时，用,隔开 共同体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。共同体每次只能存储一个值，所以共同体的长度为其最大成员的长度。 int*是一种类型—-指向int的指针。 警告：一定要在对指针应用解除引用运算符，将指针初始化位一个确定的、适当的地址。这是关于使用指针的金科玉律。 new将找到一个长度正确的内存块、并返回该内存块的地址。 1typeName * pointer_name = new typeName; 释放ps指向的内存，但不会删除指针ps本身。一定要配对的使用new和delete，否则将发生内存泄漏。不要尝试释放已经释放的内存块。只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。 在编译时给数组分配内存被称为静态编译，意味着数组是在编译时加入到程序中。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。—-动态编译，意味着数组是在程序运行时创建的。 使用new创建动态数组：只要将数组的元素类型和元素数目告诉new 12int * psome = new int [10];//new运算符返回第一个元素的地址delete [] psome;//使用new创建的数组，使用另一种格式的delete来释放 使用new和delete时，应遵守以下规则 不要使用delete来释放不是new分配的内存。 不要使用delete释放同一个内存块两次。 如果使用new[]为数组分配内存，则应使用delete[]来释放。 如果使用new为一个实体分配内存，则应使用delete来释放。 对空指针应用delete是安全的。 1type_name * pointer_name = new type_name [num_elements];//为数组分配内存的通用格式 数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址。 在cout和多数c++表达式中，char数组名、char数组以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。 一般来说，如果给cout提供一个指针，他将打印地址。但如果指针的类型为char*，则cout将显示指向的字符串。 应使用strcpy()或strncpy()，而不是赋值运算来将字符串赋给数组。 如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算。 C++有3种管理数据内存的方式：自动存储、静态存储和动态存储。 自动变量通常存储在栈中—-后进先出(LIFO). 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字static。自动存储与静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存于程序的整个生命周期(静态变量),也可能只是在特定函数被执行时存在（自动变量）。 第四章总结 数组、结构和指针是C++的3种复合类型。数组可以在一个数据对象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中的各个元素。 结构可以将多个不同类型的值存在在同一个数据对象中，可以使用成员运算符（.）来访问其中的成员。使用结构的第一步是创建结构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。 共同体可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。 指针是被设计用来存储地址的变量。指针指向它存储的地址。指针声明指出了指针指向的对象类型。对指针应用解除引用运算符，将得到指针指向的位置中的值。 字符串是以空字符为结尾的一系列字符。字符串可用括号括起的字符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在char数组中，可以用被初始化的指向字符串的char指针表示字符串。函数strlen()返回字符串的长度，其中不包括空字符。函数strcpy()将字符串从一个位置复制到另一个位置。在使用这些函数时，应当包含头文件cstring或string.h。 头文件string支持的C++string类提供了另一种对用户更友好的字符串处理方法。具体地说，string对象将根据要存储的字符串自动调整去其大小，用户可以使用赋值运算来复制字符串。 new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指针来访问这块内存。如果数据对象是简单变量，则可以使用解除引用运算符（*）来获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构，则可以用指针解除引用运算符（-&gt;）来访问其成员。 指针和数组紧密相关。如果ar是数组名，则表达式ar[i]被解释为*(ar+i)，其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。 运算符new和delete允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。自动变量是在函数中声明的变量，而静态变量是在函数外部或者使用关键字static声明的变量，这两种变量都不太灵活。自动变量在程序执行到所属的代码块时产生，在离该代码时终止。静态变量在整个程序周期内都存在。","categories":[],"tags":[]},{"title":"第三章-数据处理部分","slug":"C++学习/数据处理","date":"2020-11-30T14:24:45.000Z","updated":"2020-11-30T14:30:57.523Z","comments":true,"path":"2020/11/30/C++学习/数据处理/","link":"","permalink":"http://example.com/2020/11/30/C++%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/","excerpt":"数据处理（总结）内容总结 C++的基本类型分为两组：一组由存储整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整形从最小到最大依次是：bool、char、signed char、unsigned char、short、unsigned short、int、unsigned int、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t和char32_t，他们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任何成员，short至少16位，而int至少与short一样长，long至少32位，且至少和int一样长确切的长度取决于实现。 字符通过其数值编码来表示。I/O系统决定了编码是被解释为字符还是数字。 浮点类型可以表示小数值以及比整型能够能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double长，而double不比long double长。通常，float使用32位内存，double使用64位，long double使用80-128位。","text":"数据处理（总结）内容总结 C++的基本类型分为两组：一组由存储整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整形从最小到最大依次是：bool、char、signed char、unsigned char、short、unsigned short、int、unsigned int、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t和char32_t，他们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任何成员，short至少16位，而int至少与short一样长，long至少32位，且至少和int一样长确切的长度取决于实现。 字符通过其数值编码来表示。I/O系统决定了编码是被解释为字符还是数字。 浮点类型可以表示小数值以及比整型能够能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double长，而double不比long double长。通常，float使用32位内存，double使用64位，long double使用80-128位。 通过提供各种长度不同、有符号或无符号的类型，C++使程序员能够根据特定的数据要求选择合适的类型。 C++使用运算符来提供对数字类型的算术运算：加、减、乘、除和求模。当两个运算符对同一操作数进行时，C++的优先级和结合性规则可以确定先执行哪种操作。 对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。很多类型转换都是安全的，即可以在不损失和改变数据的情况下完成转换。例如，可以把int值转换为long值，而不会出现任何问题。对于其他的，例如浮点类型转换为整型，则需要小心。 重点摘录 面向对象编程(OOP)的本质是设计并扩展自己的数据类型。 程序必须记录的三个基本属性： 信息储存在哪里 储存什么值 存储何种类型的信息 C++命名规则： 在名称中只能使用字母字符、数字和下划线(_)。 名称的第一个字符不能是数字。 区分大写字符和小写字符。 不能将C++关键词用作字符。 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。 C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。 const限定符用于处理符号常量 1const int Months =12; const优于#define的点： 能够明确指定类型 可以使用C++的作用域规则将定义限制在特定的函数或文件中 可以将const用于更复杂的类型 通常cout会删除结尾的零。调用cout.setf()将覆盖这种行为。","categories":[],"tags":[]},{"title":"C++ learning","slug":"C++学习/开始学C++","date":"2020-11-29T12:18:44.000Z","updated":"2020-11-30T14:26:35.458Z","comments":true,"path":"2020/11/29/C++学习/开始学C++/","link":"","permalink":"http://example.com/2020/11/29/C++%E5%AD%A6%E4%B9%A0/%E5%BC%80%E5%A7%8B%E5%AD%A6C++/","excerpt":"C++ Primer Plus本文章主要是对C++入门级图书《C++ Primer Plus》的个人学习笔记，摘录本人在学习过程中的学习重点以及一些问题。以下内容按照书的各个章节进行记录，希望能把这砖头书啃下来，加油。","text":"C++ Primer Plus本文章主要是对C++入门级图书《C++ Primer Plus》的个人学习笔记，摘录本人在学习过程中的学习重点以及一些问题。以下内容按照书的各个章节进行记录，希望能把这砖头书啃下来，加油。 开始学C++(总结)1.1 内容总结 C++程序有一个或多个被称为函数的模块组成。程序从main()函数(全部小写)开始执行，该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值（如果有的话）的类型和函数期望通过参数传递给它的信息的类型。函数体由一系列位于花括号{}中的C++语句组成。 6种类型的C++语句： *声明语句：定义函数中使用的变量的名称和类型 *赋值语句：使用复制运算符(=)给变量赋值。 *消息语句：将消息发给对象，激发某种行动 *函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句 *函数原型：声明函数的返回类型、函数接收的参数数量和类型 *返回语句：将一个值从被调用的函数那里返回到调用函数中 类是用户定义的数据型规范，它详细描述了如何表示信息以及可对数据执行的操作。对象是根据类规范创建的实体 C++提供用于处理输入和输入的预定义对象(cin和cout)，他们是istream和ostream类的实例，这两个类是在iostream文件中定义的。为ostream类定义的插入运算符(&lt;&lt;)使该数据插入到输出流成为可能；为istream类定义的抽取运算符(&gt;&gt;)能够从输入流中抽取信息。cin和cout都是智能对象，能够根据程序上下文自动将信息从一种形式转换到另一种形式。 C++可以使用大量C库函数，使用时应当包含提供该函数原型的头文件。 1.2 重点摘录 C++对大小写敏感，写代码要区分大小写字符 要让窗口一直打开，可在return语句前添加cin.get()。 空括号意味着main()函数不接受任何信息，或者main()不接受任何参数。括号空着=括号中使用void。void返回类型意味着函数不返回任何值。 return 0 只适用于main（）函数，而不适用于其他函数， C++必须包含一个main()的函数。 使用cin和cout进行输入和输出的程序必须包含文件iostream。 using namespace std; 名称空间是C++特性，让厂商能够将其产品封装在一个名叫名称空间的单元中，这样就可以用名称空间来指出想使用哪个厂商的产品。 建议： using std :: cout; using std :: endl; 显示用引号括起的字符串时，通常使用换行符\\n ，在其他情况下则使用控制符 endl, endl 确保程序继续运行前刷新输出(将其立即显示在屏幕上)；而使用\\n不能提供这样的保证。 C++源代码风格遵循规则： 每条代码占一行。 每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行。 函数中的语句都相对于花括号进行缩进。 与函数名相关的圆括号周围没有空白。 在C++中，所有的变量都必须声明，且尽可能在首次使用变量前声明它。 类描述了一种数据类型的全部属性（包括可使用它执行的操作），对象是根据这些描述创建的实体。 C++函数分两种，有返回值和没有返回值 由返回值的函数将生成一个值，而这个值可赋给变量或其他表达式中使用 在使用函数之前，C++编译器必须知道函数的参数类型和返回值类型。C++提供这种信息的方式是使用函数原型的语句。C++程序应当为程序中使用的每个函数提供原型。 区别：函数原型（描述函数接口，描述的是发送给函数的信息和返回的信息） 函数定义（函数的代码） 每个C++程序都必须有一个main()函数，用户必须对它进行定义。用户自己定义的函数原型写在main（）前面。C++不允许函数嵌套 对于有返回值的函数，应用关键词return来提供返回值。 问题： 该预处理编译指令目的： 1#include &lt;iostream&gt; ​ 这将导致在最终编译之前使用iostream中的文件内容来代替编译指令。、 定义函数时，什么情况下不必使用关键词return？ 当函数的返回类型为void时，不用在函数中使用return。然而，如果不提供返回值，则可以使用： 1return；","categories":[],"tags":[]},{"title":"通讯录管理系统","slug":"项目/通讯录管理系统","date":"2020-11-26T14:05:42.000Z","updated":"2020-11-27T01:14:16.856Z","comments":true,"path":"2020/11/26/项目/通讯录管理系统/","link":"","permalink":"http://example.com/2020/11/26/%E9%A1%B9%E7%9B%AE/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"通讯录管理系统声明：本demo是根据b站黑马C++教学视频学习的，网站网址为：https://www.bilibili.com/video/BV1et411b73Z?p=72 本人在上述功能中做了一些改变，力求完善该系统，减少可能发生的bug。但是本人实力有限，也是萌新，一起学习C++。","text":"通讯录管理系统声明：本demo是根据b站黑马C++教学视频学习的，网站网址为：https://www.bilibili.com/video/BV1et411b73Z?p=72 本人在上述功能中做了一些改变，力求完善该系统，减少可能发生的bug。但是本人实力有限，也是萌新，一起学习C++。 1.系统需求通讯录是一个可以记录亲人、好友信息的工具。 本教程利用C++来实现一个通讯录管理系统 系统中需要实现的功能如下： 添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多纪录1000人。 显示联系人：显示通讯录中所有联系人信息 删除联系人：按照姓名进行删除指定联系人 查找联系人：按照姓名查看指定联系人信息 修改联系人：按照姓名重新修改指定联系人 清空联系人：清空通讯录中所有信息 退出通讯录：退出当前使用的通讯录 2.创建项目创建项目步骤如下： 创建新项目 添加文件 3.菜单功能步骤： 封装函数显示该界面，如void showMenu() 在main函数中调用封装好的函数 代码： 1234567891011121314151617181920void showMenu()&#123; cout &lt;&lt; &quot;|*************************|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 1. 添加联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 2. 显示联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 3. 删除联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 4. 查找联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 5. 修改联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 6. 清空联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 0. 退出通讯录 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|*************************|&quot; &lt;&lt; endl;&#125; 4.退出功能功能描述：退出通讯录系统 思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建 用户选择0时，执行退出，选择其他先不退出操作，也不会退出程序。 123system(&quot;pause&quot;);//用于停顿，输入一个任意值后在进行下面的操作system(&quot;cls&quot;);//用于清空界面return 0; //结束系统 5.添加联系人功能描述： 实现添加联系人功能，联系人上限为1000人，联系人信息包括（姓名、性别、年龄、联系电话、家庭住址） 添加联系人实现步骤： 设计联系人结构体 设计通讯录结构体 main()函数中创建通讯录 封装添加联系人函数 测试添加联系人功能 5.1 设计联系人结构体联系人信息包括：姓名、性别、年龄、联系电话、家庭住址 123456789//联系人结构体struct Person&#123; string m_Name; int sex; int age; string m_Tel; string m_Address;&#125;; 5.2 设计通讯录结构体设计时候可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量，设计如下： 123456//通讯录结构体struct Addressbooks&#123; Person personArray[Maxsize]; int m_size;&#125;; 5.3 main()函数中创建通讯录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int main()&#123; //创建结构体变量 Addressbooks abs; //初始化通讯录中当前的人员个数 abs.m_size = 0; //选择 int select = 0; //菜单的调用 while (true) &#123; showMenu(); cin &gt;&gt; select; switch (select) &#123; case 1://添加联系人 addPerson(&amp;abs);//利用地址传递，可以修改实参. break; case 2: showPerson(&amp;abs); break; case 3: deletePerson(&amp;abs); break; case 4: findPerson(&amp;abs); break; case 5: changePerson(&amp;abs); break; case 6: clearPerson(&amp;abs); break; case 0: cout &lt;&lt; &quot;欢迎再次使用该通讯录！！&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; default: break; &#125;; &#125; system(&quot;pause&quot;); return 0;&#125; 5.4 封装添加联系人函数 使用指针的原因：对通讯录中的信息需要进行增删改等操作，值传递无法修改变量的值，而通过指针可以修改这些值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void addPerson(Addressbooks * abs) &#123; //判断通讯录是否已满，如果满了就不再添加了 if (abs-&gt;m_size==Maxsize) &#123; cout &lt;&lt; &quot;通讯录已满，无法添加&quot; &lt;&lt; endl; return; &#125; else &#123; //添加姓名 string name; cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[abs-&gt;m_size].m_Name = name; //性别 cout &lt;&lt; &quot;请输入性别是什么： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl; int sex = 0; cin &gt;&gt; sex; cin.get(); while (true) &#123; if (sex == 1 || sex == 2) &#123; abs-&gt;personArray[abs-&gt;m_size].sex = sex; break; &#125; else &#123; cout &lt;&lt; &quot;请输入正确的数字！&quot; &lt;&lt; endl; cin &gt;&gt; sex; cin.get(); &#125; &#125; //年龄 cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl; int age = 0; cin &gt;&gt; age; cin.get(); abs-&gt;personArray[abs-&gt;m_size].age = age; //电话 cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl; string phone; cin &gt;&gt; phone; abs-&gt;personArray[abs-&gt;m_size].m_Tel = phone; //住址 cout &lt;&lt; &quot;请输入家庭地址：&quot; &lt;&lt; endl; string address; cin &gt;&gt; address; abs-&gt;personArray[abs-&gt;m_size].m_Address = address; //更新通讯录人数 abs-&gt;m_size++; cout &lt;&lt; &quot;你添加成功了！！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏操作 &#125;&#125; 6.显示联系人功能描述：显示通讯录中已有联系人信息 显示联系人实现步骤： 封装显示联系人函数 测试显示联系人功能 6.1封装显示联系人函数显示联系人代码： 123456789101112131415161718192021void showPerson(Addressbooks * abs) &#123; //首先判断通讯录中人数是否为0 if (abs-&gt;m_size == 0) &#123; cout &lt;&lt; &quot;当前记录为空。&quot; &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; abs-&gt;m_size; i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[i].sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[i].age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;电话： &quot; &lt;&lt; abs-&gt;personArray[i].m_Tel &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;家庭住址： &quot; &lt;&lt; abs-&gt;personArray[i].m_Address &lt;&lt;&quot;\\t&quot;&lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125; 7.删除联系人功能描述：按照姓名进行删除指定联系人 删除联系人实现步骤： 封装检测联系人是否存在 封装删除联系人函数 测试联系人删除功能 设计思路： 删除联系人前，先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人。因此可以先把检测联系人封装在一个函数中，如果存在，返回联系人在通讯路中的位置，不存在返回-1。 检测函数部分： 1234567891011121314int isExist(Addressbooks * abs, string name) &#123; for (int i = 0; i &lt; abs-&gt;m_size ; i++) &#123; if (abs-&gt;personArray[i].m_Name==name) &#123; return i; &#125; else &#123; return -1;//如果遍历结束都没有找到则返回-1 &#125; &#125;&#125; 删除部分： 1234567891011121314151617181920212223void deletePerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入要删除的联系人： &quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) &#123; for (int i = 0; i &lt; abs-&gt;m_size; i++) &#123; //数据前移 abs-&gt;personArray[i] = abs-&gt;personArray[i + 1]; &#125; abs-&gt;m_size--; cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125; 8.查找联系人功能描述：按照姓名查看指定联系人信息 查找联系人实现步骤 封装查找联系人函数 测试查找指定联系人 8.1封装查找联系人函数实现思路：判断用户指定的联系人是否存在，如果存在显示信息，不存在则显示查无此人 查找联系人代码： 12345678910111213141516171819202122void findPerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入要查找的名字：&quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int reg = isExist(abs, name); if (reg != -1) &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; abs-&gt;personArray[reg].m_Name &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;性别： &quot; &lt;&lt; abs-&gt;personArray[reg].sex &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; abs-&gt;personArray[reg].age &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;电话号码： &quot; &lt;&lt; abs-&gt;personArray[reg].m_Tel &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;住址： &quot; &lt;&lt; abs-&gt;personArray[reg].m_Address &lt;&lt; &#x27;\\t&#x27; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; 9.修改联系人功能描述：按照姓名重新修改指定联系人 修改联系人实现步骤 封装修改联系人函数 测试修改联系人功能 9.1封装修改联系人函数实现思路：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人 修改联系人代码 123456789101112131415161718192021222324252627282930313233343536void changePerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入需要修改信息的联系人的姓名： &quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int reg = isExist(abs, name); if (reg !=-1) &#123; //姓名 string name; cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[reg].m_Name = name; //年龄 int age; cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl; cin &gt;&gt; age; abs-&gt;personArray[reg].age = age; //电话 string phone; cout &lt;&lt; &quot;请输入电话号码： &quot; &lt;&lt; endl; cin &gt;&gt; phone; abs-&gt;personArray[reg].m_Tel = phone; //住址 string familyaddress; cout &lt;&lt; &quot;请输入你的住址&quot; &lt;&lt; endl; cin &gt;&gt; familyaddress; abs-&gt;personArray[reg].m_Address = familyaddress; &#125; else &#123; cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125; 10.清空联系人功能描述：清空通讯录中所有信息 清空联系人实现步骤 封装清空联系人函数 测试清空联系人 10.1封装清空联系人函数实现思路：将通讯录所有联系人信息清除掉，只要将通讯录的联系人数量重置为0，做逻辑清空即可 清空联系人代码： 12345678910111213141516171819202122232425//清空联系人void clearPerson(Addressbooks * abs)&#123; //判断 cout &lt;&lt; &quot;是否确定需要清空该通讯录？&lt;y or n&gt;&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (c == &#x27;y&#x27; || c==&#x27;yes&#x27;) &#123; //清空操作 abs-&gt;m_size = 0;//将当期记录联系人重置为0，做逻辑清空操作 cout &lt;&lt; &quot;通讯录已清空&quot; &lt;&lt; endl; &#125; else if (c == &#x27;n&#x27;||c==&#x27;no&#x27; ) &#123; return; &#125; else if (c !=&#x27;y&#x27;||c !=&#x27;n&#x27;) &#123; cout &lt;&lt; &quot;请重新输入正确的选择！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125; 综上完整代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292#include&lt;iostream&gt;#include&lt;string&gt;#define Maxsize 1000using namespace std;//菜单界面void showMenu()&#123; cout &lt;&lt; &quot;|*************************|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 1. 添加联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 2. 显示联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 3. 删除联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 4. 查找联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 5. 修改联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 6. 清空联系人 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|***** 0. 退出通讯录 *****|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|-------------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|*************************|&quot; &lt;&lt; endl;&#125;//联系人结构体struct Person&#123; string m_Name; int sex; int age; string m_Tel; string m_Address;&#125;;//通讯录结构体struct Addressbooks&#123; Person personArray[Maxsize]; int m_size;&#125;;//添加联系人void addPerson(Addressbooks * abs) &#123; //判断通讯录是否已满，如果满了就不再添加了 if (abs-&gt;m_size==Maxsize) &#123; cout &lt;&lt; &quot;通讯录已满，无法添加&quot; &lt;&lt; endl; return; &#125; else &#123; //添加姓名 string name; cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[abs-&gt;m_size].m_Name = name; //性别 cout &lt;&lt; &quot;请输入性别是什么： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl; int sex = 0; cin &gt;&gt; sex; cin.get(); while (true) &#123; if (sex == 1 || sex == 2) &#123; abs-&gt;personArray[abs-&gt;m_size].sex = sex; break; &#125; else &#123; cout &lt;&lt; &quot;请输入正确的数字！&quot; &lt;&lt; endl; cin &gt;&gt; sex; cin.get(); &#125; &#125; //年龄 cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl; int age = 0; cin &gt;&gt; age; cin.get(); abs-&gt;personArray[abs-&gt;m_size].age = age; //电话 cout &lt;&lt; &quot;请输入电话：&quot; &lt;&lt; endl; string phone; cin &gt;&gt; phone; abs-&gt;personArray[abs-&gt;m_size].m_Tel = phone; //住址 cout &lt;&lt; &quot;请输入家庭地址：&quot; &lt;&lt; endl; string address; cin &gt;&gt; address; abs-&gt;personArray[abs-&gt;m_size].m_Address = address; //更新通讯录人数 abs-&gt;m_size++; cout &lt;&lt; &quot;你添加成功了！！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏操作 &#125;&#125;//显示联系人void showPerson(Addressbooks * abs) &#123; //首先判断通讯录中人数是否为0 if (abs-&gt;m_size == 0) &#123; cout &lt;&lt; &quot;当前记录为空。&quot; &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; abs-&gt;m_size; i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[i].sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[i].age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;电话： &quot; &lt;&lt; abs-&gt;personArray[i].m_Tel &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;家庭住址： &quot; &lt;&lt; abs-&gt;personArray[i].m_Address &lt;&lt;&quot;\\t&quot;&lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125;//检测联系人是否存在,如果存在，返回联系人所在数组中的位置，不存在返回-1int isExist(Addressbooks * abs, string name) &#123; for (int i = 0; i &lt; abs-&gt;m_size ; i++) &#123; if (abs-&gt;personArray[i].m_Name==name) &#123; return i; &#125; else &#123; return -1;//如果遍历结束都没有找到则返回-1 &#125; &#125;&#125;//删除指定的联系人void deletePerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入要删除的联系人： &quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) &#123; for (int i = 0; i &lt; abs-&gt;m_size; i++) &#123; //数据前移 abs-&gt;personArray[i] = abs-&gt;personArray[i + 1]; &#125; abs-&gt;m_size--; cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125;//查找联系人void findPerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入要查找的名字：&quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int reg = isExist(abs, name); if (reg != -1) &#123; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; abs-&gt;personArray[reg].m_Name &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;性别： &quot; &lt;&lt; abs-&gt;personArray[reg].sex &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; abs-&gt;personArray[reg].age &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;电话号码： &quot; &lt;&lt; abs-&gt;personArray[reg].m_Tel &lt;&lt; &#x27;\\t&#x27;; cout &lt;&lt; &quot;住址： &quot; &lt;&lt; abs-&gt;personArray[reg].m_Address &lt;&lt; &#x27;\\t&#x27; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;void changePerson(Addressbooks * abs)&#123; cout &lt;&lt; &quot;请输入需要修改信息的联系人的姓名： &quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int reg = isExist(abs, name); if (reg !=-1) &#123; //姓名 string name; cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[reg].m_Name = name; //年龄 int age; cout &lt;&lt; &quot;请输入年龄： &quot; &lt;&lt; endl; cin &gt;&gt; age; abs-&gt;personArray[reg].age = age; //电话 string phone; cout &lt;&lt; &quot;请输入电话号码： &quot; &lt;&lt; endl; cin &gt;&gt; phone; abs-&gt;personArray[reg].m_Tel = phone; //住址 string familyaddress; cout &lt;&lt; &quot;请输入你的住址&quot; &lt;&lt; endl; cin &gt;&gt; familyaddress; abs-&gt;personArray[reg].m_Address = familyaddress; &#125; else &#123; cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125;//清空联系人void clearPerson(Addressbooks * abs)&#123; //判断 cout &lt;&lt; &quot;是否确定需要清空该通讯录？&lt;y or n&gt;&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (c == &#x27;y&#x27; || c==&#x27;yes&#x27;) &#123; //清空操作 abs-&gt;m_size = 0;//将当期记录联系人重置为0，做逻辑清空操作 cout &lt;&lt; &quot;通讯录已清空&quot; &lt;&lt; endl; &#125; else if (c == &#x27;n&#x27;||c==&#x27;no&#x27; ) &#123; return; &#125; else if (c !=&#x27;y&#x27;||c !=&#x27;n&#x27;) &#123; cout &lt;&lt; &quot;请重新输入正确的选择！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125;int main()&#123; //创建结构体变量 Addressbooks abs; //初始化通讯录中当前的人员个数 abs.m_size = 0; //选择 int select = 0; //菜单的调用 while (true) &#123; showMenu(); cin &gt;&gt; select; switch (select) &#123; case 1://添加联系人 addPerson(&amp;abs);//利用地址传递，可以修改实参. break; case 2: showPerson(&amp;abs); break; case 3: deletePerson(&amp;abs); break; case 4: findPerson(&amp;abs); break; case 5: changePerson(&amp;abs); break; case 6: clearPerson(&amp;abs); break; case 0: cout &lt;&lt; &quot;欢迎再次使用该通讯录！！&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; default: break; &#125;; &#125; system(&quot;pause&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"MySql 基础学习","slug":"瞎几把学/MySql-基础学习","date":"2020-11-25T05:40:49.000Z","updated":"2020-11-25T05:40:49.938Z","comments":true,"path":"2020/11/25/瞎几把学/MySql-基础学习/","link":"","permalink":"http://example.com/2020/11/25/%E7%9E%8E%E5%87%A0%E6%8A%8A%E5%AD%A6/MySql-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"My First Blog","slug":"My-First-Blog","date":"2020-11-25T02:03:04.000Z","updated":"2020-11-25T05:45:19.627Z","comments":true,"path":"2020/11/25/My-First-Blog/","link":"","permalink":"http://example.com/2020/11/25/My-First-Blog/","excerpt":"","text":"终于开始写博客了，加油！","categories":[],"tags":[]}],"categories":[],"tags":[]}